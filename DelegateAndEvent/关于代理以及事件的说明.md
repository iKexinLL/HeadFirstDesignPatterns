以下内容来自: http://www.tracefact.net/tech/009.html
1. 如果把 delegate1 声明为 private会怎样？
结果就是：**这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？**
2. 再看看把delegate1 声明为 public 会怎样？
结果就是：**在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。**
3. 如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？
**答案是使用属性对字段进行封装。**
4. 于是，*结合1,2,3*,Event出场了，它封装了委托类型的变量，使得：
**在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。**
------
以下内容来自<C#本质论>
长期以来,经验丰富的C和C++程序员利用"函数指针"将*方法的引用作为参数传给另外一个方法*.C#使用委托提供相同的功能.
event关键字的作用就是提供额外的封装,避免不小心的取消其他订阅者.
> 委托的两个关键问题:
> 1. 封装订阅 -> 委托可能错误的使用=而不是+=导致剔除其他方法.\
> 最好的解决办法是仅为[包容类][^1]内容的对象提供对赋值操作的支持. \
> event关键字的作用就是提供额外的封装,避免不小心取消其他订阅者.
> 2. 封装发布 -> 事件确保只有包容类才能触发事件通知.\
> 这种情况会导致对象在任意情况下都能主动调用"通知",造成无用通知(因为可能未发生变化)


[^1]: 个人认为,"包容类"指的是包括事件的类
